<xml xmlns="https://developers.google.com/blockly/xml"><block type="pxt-on-start" id="OVKk=jX[T9vsH]d{c-3O" x="0" y="0"><statement name="HANDLER"><block type="typescript_statement" id="`03-d/|i`ofq`:ra}@6=" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace BMP280 {" line1="    enum BMP280_I2C_ADDRESS {" line2="        //% block=&quot;0x76&quot;" line3="        ADDR_0x76 = 0x76," line4="        //% block=&quot;0x77&quot;" line5="        ADDR_0x77 = 0x77" line6="    }" line7="" line8="    let BMP280_I2C_ADDR = BMP280_I2C_ADDRESS.ADDR_0x76" line9="" line10="    function setreg(reg: number, dat: number): void {" line11="        let buf = pins.createBuffer(2);" line12="        buf[0] = reg;" line13="        buf[1] = dat;" line14="        pins.i2cWriteBuffer(BMP280_I2C_ADDR, buf);" line15="    }" line16="" line17="    function getreg(reg: number): number {" line18="        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);" line19="        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.UInt8BE);" line20="    }" line21="" line22="    function getUInt16LE(reg: number): number {" line23="        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);" line24="        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.UInt16LE);" line25="    }" line26="" line27="    function getInt16LE(reg: number): number {" line28="        pins.i2cWriteNumber(BMP280_I2C_ADDR, reg, NumberFormat.UInt8BE);" line29="        return pins.i2cReadNumber(BMP280_I2C_ADDR, NumberFormat.Int16LE);" line30="    }" line31="" line32="    let dig_T1 = getUInt16LE(0x88)" line33="    let dig_T2 = getInt16LE(0x8A)" line34="    let dig_T3 = getInt16LE(0x8C)" line35="    let dig_P1 = getUInt16LE(0x8E)" line36="    let dig_P2 = getInt16LE(0x90)" line37="    let dig_P3 = getInt16LE(0x92)" line38="    let dig_P4 = getInt16LE(0x94)" line39="    let dig_P5 = getInt16LE(0x96)" line40="    let dig_P6 = getInt16LE(0x98)" line41="    let dig_P7 = getInt16LE(0x9A)" line42="    let dig_P8 = getInt16LE(0x9C)" line43="    let dig_P9 = getInt16LE(0x9E)" line44="    setreg(0xF4, 0x2F)" line45="    setreg(0xF5, 0x0C)" line46="    let T = 0" line47="    let P = 0" line48="" line49="    function get(): void {" line50="        let adc_T = (getreg(0xFA) &lt;&lt; 12) + (getreg(0xFB) &lt;&lt; 4) + (getreg(0xFC) &gt;&gt; 4)" line51="        let var1 = (((adc_T &gt;&gt; 3) - (dig_T1 &lt;&lt; 1)) * dig_T2) &gt;&gt; 11" line52="        let var2 = (((((adc_T &gt;&gt; 4) - dig_T1) * ((adc_T &gt;&gt; 4) - dig_T1)) &gt;&gt; 12) * dig_T3) &gt;&gt; 14" line53="        let t = var1 + var2" line54="        T = Math.idiv(((t * 5 + 128) &gt;&gt; 8), 100)" line55="        var1 = (t &gt;&gt; 1) - 64000" line56="        var2 = (((var1 &gt;&gt; 2) * (var1 &gt;&gt; 2)) &gt;&gt; 11) * dig_P6" line57="        var2 = var2 + ((var1 * dig_P5) &lt;&lt; 1)" line58="        var2 = (var2 &gt;&gt; 2) + (dig_P4 &lt;&lt; 16)" line59="        var1 = (((dig_P3 * ((var1 &gt;&gt; 2) * (var1 &gt;&gt; 2)) &gt;&gt; 13) &gt;&gt; 3) + (((dig_P2) * var1) &gt;&gt; 1)) &gt;&gt; 18" line60="        var1 = ((32768 + var1) * dig_P1) &gt;&gt; 15" line61="        if (var1 == 0)" line62="            return; // avoid exception caused by division by zero" line63="        let adc_P = (getreg(0xF7) &lt;&lt; 12) + (getreg(0xF8) &lt;&lt; 4) + (getreg(0xF9) &gt;&gt; 4)" line64="        let _p = ((1048576 - adc_P) - (var2 &gt;&gt; 12)) * 3125" line65="        _p = Math.idiv(_p, var1) * 2;" line66="        var1 = (dig_P9 * (((_p &gt;&gt; 3) * (_p &gt;&gt; 3)) &gt;&gt; 13)) &gt;&gt; 12" line67="        var2 = (((_p &gt;&gt; 2)) * dig_P8) &gt;&gt; 13" line68="        P = _p + ((var1 + var2 + dig_P7) &gt;&gt; 4)" line69="    }" line70="" line71="    /**" line72="     * get pressure" line73="     */" line74="    //% blockId=&quot;BMP280_GET_PRESSURE&quot; block=&quot;get pressures&quot;" line75="    //% weight=80 blockGap=8" line76="    export function pressure(): number {" line77="        get();" line78="        return P;" line79="    }" line80="" line81="    /**" line82="     * get temperature" line83="     */" line84="    //% blockId=&quot;BMP280_GET_TEMPERATURE&quot; block=&quot;get temperature&quot;" line85="    //% weight=80 blockGap=8" line86="    export function temperature(): number {" line87="        get();" line88="        return T;" line89="    }" line90="" line91="    /**" line92="     * power on" line93="     */" line94="    //% blockId=&quot;BMP280_POWER_ON&quot; block=&quot;Power On&quot;" line95="    //% weight=61 blockGap=8" line96="    export function PowerOn() {" line97="        setreg(0xF4, 0x2F)" line98="    }" line99="" line100="    /**" line101="     * power off" line102="     */" line103="    //% blockId=&quot;BMP280_POWER_OFF&quot; block=&quot;Power Off&quot;" line104="    //% weight=60 blockGap=8" line105="    export function PowerOff() {" line106="        setreg(0xF4, 0)" line107="    }" line108="" line109="    /**" line110="     * set I2C address" line111="     */" line112="    //% blockId=&quot;BMP280_SET_ADDRESS&quot; block=&quot;set address %addr&quot;" line113="    //% weight=50 blockGap=8" line114="    export function Address(addr: BMP280_I2C_ADDRESS) {" line115="        BMP280_I2C_ADDR = addr" line116="    }" line117="}" numlines="118"></mutation><next><block type="typescript_statement" id=",MHOEDhn6%lEsPDf2}wu" editable="false"><mutation xmlns="http://www.w3.org/1999/xhtml" line0="namespace NEO6M {" line1="" line2="    function parseRMC(sentence: string) {" line3="        // serial.writeLine(&quot;Parts:&quot; + sentence);" line4="        parts = sentence.split(&quot;,&quot;)" line5="        date = parts[9]" line6="    }" line7="    function parseGPSData(data: string) {" line8="        lines = data.split(&quot;$&quot;)" line9="        for (let line of lines) {" line10="            if (line.charAt(0) == &quot;G&quot; &amp;&amp; line.charAt(1) == &quot;P&quot; &amp;&amp; line.charAt(2) == &quot;G&quot; &amp;&amp; line.charAt(3) == &quot;G&quot; &amp;&amp; line.charAt(4) == &quot;A&quot;) {" line11="                parseGGA(line)" line12="                //serial.writeLine(&quot;GGA - Time: &quot; + time + &quot; Lat: &quot; + lat + &quot; Lon: &quot; + lon + &quot; Satellites: &quot; + satellites + &quot; Alttitude: &quot; + alltitude)" line13="            } else if (line.charAt(0) == &quot;G&quot; &amp;&amp; line.charAt(1) == &quot;P&quot; &amp;&amp; line.charAt(2) == &quot;R&quot; &amp;&amp; line.charAt(3) == &quot;M&quot; &amp;&amp; line.charAt(4) == &quot;C&quot;) {" line14="                parseRMC(line)" line15="                //serial.writeLine(&quot;RMC - Time: &quot; + time + &quot; Date: &quot; + date + &quot; Lat: &quot; + lat + &quot; Lon: &quot; + lon)" line16="            }" line17="        }" line18="    }" line19="    function parseGGA(sentence: string) {" line20="        parts = sentence.split(&quot;,&quot;)" line21="        time = parts[1]" line22="        lat = &quot;&quot; + parts[2].substr(0, 2) + &quot; &quot; + parts[2].substr(2, parts[2].length) + parts[3]" line23="        lon = &quot;&quot; + parts[4].substr(0, 3) + &quot; &quot; + parts[4].substr(3, parts[2].length) + parts[5]" line24="        satellites = parseInt(parts[7])" line25="        alltitude = parseInt(parts[9])" line26="    }" line27="" line28="    function collectGPSData() {" line29="        let buff: Buffer" line30="        startTime = input.runningTime()" line31="        serial.redirect(" line32="            SerialPin.P0," line33="            SerialPin.P1," line34="            BaudRate.BaudRate9600" line35="        )" line36="        while (input.runningTime() - startTime &lt; 1100) {" line37="            buff = serial.readBuffer(1)" line38="            collectedData = &quot;&quot; + collectedData + buff.toString()" line39="        }" line40="        parseGPSData(collectedData)" line41="        serial.redirectToUSB()" line42="    }" line43="" line44="    /**" line45="     * Get coordinates" line46="     */" line47="    //% blockId=&quot;NEO6M_RMC_PARSE&quot; block=&quot;Get coordinates&quot;" line48="    //% weight=80 blockGap=8" line49="    export function get_coordinates(): string" line50="    {" line51="        collectGPSData()" line52="        return lat + &quot; &quot; + lon" line53="    }" line54="    let alltitude: number" line55="    let parts3: string[] = []" line56="    let collectedData = &quot;&quot;" line57="    let startTime = 0" line58="    let dotPos = 0" line59="    let satellites = 0" line60="    let lines: string[] = []" line61="    let date = &quot;&quot;" line62="    let time = &quot;&quot;" line63="    let parts: string[] = []" line64="    let totalSatellites = &quot;&quot;" line65="    let gsvData = 0" line66="    let rmcData = 0" line67="    let ggaData = 0" line68="    let parts2: number[] = []" line69="    let time2 = &quot;&quot;" line70="    let gpsData = &quot;&quot;" line71="    let lon: string" line72="    let lat: string" line73="}" numlines="74"></mutation></block></next></block></statement></block></xml>